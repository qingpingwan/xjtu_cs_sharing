## 图论

### 基础概念

 #### 存储

1. 邻接矩阵法：用n*n的二维矩阵，将每行与每列都看作每个节点，
     矩阵里面某个行列对应数值表示这两个节点之间是否连接或者也可以定义为它们的权值。
     对于无向图而言，邻接矩阵还是对阵矩阵，在存储时可以压缩存储。 
     但存储稀疏矩阵时空间会有大量浪费。适合存储稠密图。
     ![](https://img-blog.csdnimg.cn/2a7d83f0822e4671936447372fe89487.png)
     
2. 邻接表法：
   
     通过链表来将连接某个节点的节点给串联起来。
     适合于存储稀疏图。
     
     二者对比：
     ![图论-20230925204242-2023-09-25-20-42-43](https://raw.githubusercontent.com/qingpingwan/note_picture/main/image_share_aux/图论-20230925204242-2023-09-25-20-42-43)
     
     
     
3. 十字链表：

     适合存储有向图，也没有邻接表找有向图入边不方便的问题。
     ![](https://img-blog.csdnimg.cn/20190219144848368.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3kxMDl5,size_16,color_FFFFFF,t_70)


​     

4. 邻接多重表：
     只能用于存储无向图。
     删除边，删除节点的操作都很方便。
     ![图论-20230925204332-2023-09-25-20-43-33](https://raw.githubusercontent.com/qingpingwan/note_picture/main/image_share_aux/图论-20230925204332-2023-09-25-20-43-33)

     

总的来说，**邻接矩阵** 与 **邻接表** 实际手写算法中使用较多。

十字链表与邻接多重表较复杂，仅需掌握其原理与实现方法即可。



### 图的遍历

同一个图的 **邻接矩阵** 表示法唯一，因此遍历结果的顺序唯一。

同一个图的 **邻接表** 表示方法不唯一，因此遍历结果可能不唯一。

#### BFS

（详见搜索章节）

#### DFS

（详见搜索章节）

#### 搜索与图的遍历

BFS与DFS绝不是只能使用在图的遍历搜索的过程中，
它们可以对遇到的大部分问题进行搜索。

在对于一个一般的算法问题，
我们把一个问题的求解看作是对问题状态空间的对应，
也就是将问题空间类比为一张图，
那么求解这个算法问题就相当于在在图上进行深度优先遍历。



### 最小生成树

n个节点的无向连通图的生成树有 n -1 个节点
生成树是不会有环的
注意只有无向图才有生成树

对于一个 **带权连通无向图** G = ( V , E ) ，找出该图的一个生成树 T，
使得该生成树的边权值和是最小的，称树T是G的最小生成树(MST)。

注意最小生成树可能有多个

#### Prim算法

运用贪心思维找局部最优解
可以从任意一个顶点开始构建最小生成树，连接这个顶点权值最小的边所对应的顶点
每次都以最小代价纳入一个新顶点到生成树中来，直到所有顶点都被纳入。

Prim适合于边比较稠密的图，这类图在存储时主要使用邻接矩阵进行存储。
因为一般Prim算法在存储图时就是以邻接矩阵的方式来存储图。

这个算法还可以类比Dijkstra算法来通过堆进行优化
也就是寻找目前距离生成树集合最近的点时可以使用堆进行优化。
```C++
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=510,INF=0x3f3f3f3f;
int n,m;
int Graph[N][N];  //使用邻接矩阵来存储图
bool st[N];       //标识一个节点是否在生成树的集合中
int Distance[N];
//用来标识目前没有在生成树集合中的节点距离该集合的最短路径

int Prim(){
	memset(Distance,0x3f,sizeof Distance);
	int res=0;
	for(int i=1;i<n;i++){
		int t=-1;
		for(int j=1;j<=n;j++){
			if(!st[j]&&(t==-1||Distance[t]>Distance[j]))
				t=j;
		//通过遍历Distance数组来找出目前距离生成树集合最近的点
		}
		if(i&&Distance[t]==INF) return INF;
		//如果现在最近的节点都是无穷远，那么说明不连通
		
		if(i) res+=Distance[t];
		//将新加入节点的距离算入生成树的总权值和中
		for(int j=1;j<=n;j++) Distance[j]=min(Distance[j],Graph[t][j]);
		//遍历所有节点，更新它们距离生成树集合的距离
		//注意这一步不能和上一步调换位置，一定先更新res值再更新Distance值
		//否则更新res值时可能用的新Distance值来加的，造成错误
		
		st[t]=true;
	}
	return res;
}

int main(){
	scanf("%d %d",&n,&m);
	memset(Graph,0x3f,sizeof Graph);
	while(m--){
		int a,b,c;
		scanf("%d %d %d",&a,&b,&c);
		Graph[a][b]=Graph[b][a]=min(Graph[a][b],c);
		//存储边时注意重边的影响，只存最小边
	}
	int t = Prim();
	if(t==INF) puts("impossible");
	else printf("%d\n",t);
	return 0;
}
```

#### Kruskal算法

也是采用贪心策略，不过是从边的角度来考虑问题
将所有边按照权值进行排序后，依次按权值从小到大考察这些边
如果一条边的两个端节点是不连通的，
那么就将这条边加入到最小生成树的集合之中。
如果边的两个端节点连通，那么就跳过这个边。

重复以上操作直到连接了n-1条边，此时就是最小生成树

在实现上我们可以借用并查集来判断两个节点是否是连通的。

#### Boruvka算法

Boruvka算法是一种用于求解最小生成树的贪心算法。
他也是最古老的最小生成树算法之一
它的基本思想是:

1. 初始时,将每个顶点看成是一个独立的树。
2. 找出每个树连接其他不同树的最小权值边, 连接这条边。
     这会使一些独立的树连接成更大的树。
3. 对现有的每棵树重复步骤2,直到所有顶点都在同一棵树内,
     这棵树就是最小生成树。

Boruvka算法像是Kruskal算法的多路增广版
它一次遍历就将每个独立的树连接其他树的最小权值边都加入到生成树中
在寻找最小权值边的过程中又考虑了树的生长

一般该算法并不一定优于Kruskal算法，仅作为参考算法来了解。



### 最短路问题

 #### Dijkstra

单源最短路径算法，用于计算某个节点到其他任意节点的最短路径问题
可以是带权无向图也可以是带权有向图
注意这个算法不适合用于带负权值的带权图

采用贪心思想。
假设$V_{0}$是路径初始节点，求所有节点距离$V_{0}$的最短路径值

dist数组保存目前$V_{0}$到达该节点的最短路径长度
path数组用于存储该节点在目前最短路径上的前驱节点
final数组用于标记该节点的目前最短路径长度是否是最终值

每次将还未在子图中，且dist数组对应值最小的节点加入子路径中，并标记final数组位。
之后遍历新加入节点的后继节点，从而更新dist数组以与path数组值。
注意这里的最短距离定义的是与目前子图通过一条边连通的节点距离源点的最短距离
所以每次更新最短距离时只需要更新新加入子图的节点的后继节点即可。

最后得到$V_{0}$节点到所有节点的最短路径值并且通过path数组可以得到具体的路径。

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
//图的输入格式为先输入点和边的数量
//在按照x y z每行来输入x点与y点相连，权值为z
//输出第一个与最后一个点的最短路，没有则输出-1
using namespace std;
const int N=510; //输入数据最多500个点
int n,m;
int graph[N][N];
int distance[N];
bool st[N]; 
int Dijkstra(){
    memset(distance,0x3f,sizeof(distance));
    distance[1]=0;
   
    for(int i = 0; i < n; i++){
        
        int t =-1;  //t表示这次循环时加入的点
        for(int j=1;j<=n;j++)
            if(!st[j]&&(t==-1 || distance[t] > distance[j]))
                
                t=j;
        
        st[t]==true; 
        for(int j=1;j<=n;j++){
            distance[j]=min(distance[j],distance[t]+graph[t][j]);
            
        }
        if(distance[n]==0x3f3f3f3f) return -1;
        return distance[n]; 
    }

}
int main(){
    scanf("%d %d",&n,&m);
    memset(graph, 0x3f,sizeof(graph));
    while(m--){
        int a,b,c;
        scanf("%d %d %d",&a,&b,&c);
        graph[a][b] = min(g[a][b],c);
    }
    int t =Dijkstra();
    printf("%d\n",t);
    return 0;
}

```



#### Bellman-Ford

该算法可以求带负权边的单源最短路径值
本质是利用了动态规划的思想
一般也要求图中不能存在负权值环
如果存在负权值环时，该算法可以求得最多经过K条边的最短路径值
或者也可以用来判断图中是否存在负权环

该算法不同于Dijkstra算法对于点进行遍历
**Bellman-Ford算法是对于图中的边进行遍历**
每一圈遍历时遍历图中的所有边，更新该边指向的节点的Distance数组值
注意在更新Distance数组时要使用上一圈更新完成后备份的Distance数组
而不是这一圈正在更新的Distance数组值，这就是动态规划的思想

进行第K圈这样的遍历后，求得的Distance数组就是最多经过K条边的最短路径值

显然对于无负权值环的图，即使有负值边的存在，在经过n-1圈遍历后
Distance数组依旧可以求出最终最短路径值

所以为了判断是否图中有负权值环，可以在进行了n-1圈遍历的基础上进行第n圈遍历
如果此时Distance数组还会更新，那么就证明图中存在负权值环了

#### SPFA算法

在Bellman的遍历边过程中，我们对图中每一条边都要实施松弛操作
但只有少量的边可以松弛成功
不难发现，只有某个点在上一轮松弛成功时
以这个点为起始点的边所指向的终止节点在下一轮松弛操作中才有可能成功

所以我们将每一次松弛成功的节点都入队
此时队列中的节点都是曾经松弛成功的节点
我们只需要对目前队列中的节点的指向邻接节点进行松弛操作即可
通过出队一个节点后遍历这个节点的指出相邻节点就可以实现

因为规定了没有负值环，所以spfa算法不用考虑所求出的最短路径至多经过了几条边
所以在spfa算法中不需要考虑现在是第几圈来遍历图中所有边
只需要一直遍历，直到所有点的最短路径值是稳定的，也就是队列为空时就行。

使用spfa算法求图中是否是负权值环的思路与Bellman算法相同
需要在spfa算法中自己新建一个count数组
每次松弛操作成功后更新count数组值
用count数组来存储每个最短路径所经过边的数量
一直进行循环，在循环内判断count数组的某个值是否大于n
如果最短路径经过的边数大于n，那么一定说明路径中存在负权环
如果不存在负权环，那么最后会跳出spfa的循环

需要注意在第一次入队时要把图中所有节点都入队
如果还像之前算法那样只入队一个节点s，那么有些节点可能和s节点是不连通的
这些不连通的节点之间存在负权值环那么算法是无法判断出
将这些冗余节点的入队就像Bellman算法中那些冗余遍历一样
对结果的准确性是不影响的，只会增大算法的时间开销而已。



#### Johnson

如果对每个边使用一个Bellman-Ford算法来实现全源最短路，那么复杂度为O(mn^2)
显然不如使用堆优化的Dijkstra算法来实现全源最短路，复杂度是O(mnlogm)
所以关键在于对有负权图的改造使得可以使用Dijkstra算法

首先一定不能通过给所有边加上一个相同正常数来使得图中没有负权边
因为不同的最短路径经过的边数不定，所以加上的常数个数也是不同会导致错误

我们考虑新建一个虚拟节点0，让它到任意节点连一条边，且边的权值全部为0
然后以0节点来使用单源Bellman-Ford或者SPFA求出Distance数组并将其存储到 h 数组
之后我们让原本图中连接 u 到 v 节点的边的权值变为  $w_{u,v}+h_{u}-h_{v}$
之后再用更新后的权值给原本的图中的每个点使用Dijkstra就可以了

现在证明改变边的权值后最终结果不变：
不妨从s节点到t节点中任意取出一条     $s->p_{1}->p_{2}->p_{3}->t$
在权值改变了的图中这条路径长度为:
$(w_{s,p1}+h_{s}-h_{p1})+(w_{p1,p2}+h_{p1}-h_{p2})+(w_{p2,p3}+h_{p2}-h_{p3})+(w_{p3,t}+h_{p3}-h_{t})$
=  $w_{s,p1}+w_{p1,p2}+w_{p2,p3}+w_{p3,t}+h_{s}-h_{t}$
显然任意两点之间的不同路径即使经过的边的数量是不同的，它们相差也是常数   $h_{s}-h_{t}$

再注意到三角不等式显然有：$h_{v}\le w_{u,v}+h_{u}$
也就是虚拟节点0到v节点的最短路一定小于虚拟节点0到u的最短路加上u到v的最短路
所以对于修正后的边的权值    $w+h_{u}-h_{v}$   是恒正的
也就可以正常使用堆优化后的Dijkstra算法了



## 补充内容



### 图的匹配问题

#### 二分图

二分图又称二部图，一般只考虑无向图。
二分图节点可以分为两个集合A，B，
满足每个集合内部的节点之间是没有边相连的。
也可得知二分图中没有长度为奇数的



#### 二分图的判断

最简单的我们使用染色法来判断。

显然我们将图中的某一点染黑后，按照二分图的定义，
和它相邻的任意节点都要染为白色
我们按照这样的规则进行不断染色与查找判断
任意一个节点只能被重复的染同一种颜色
如果所有点都满足这样的规则就是二分图。
反之如果有一个点被重复染了不同的颜色，那么说明不是二分图

在遍历图中的所有节点时我们可以考虑使用BFS或者DFS来遍历这个图

#### 二分图的最大匹配

设G为二分图，若在G的一个子图M中，任意两条边都没有公共节点
那么称M为二分图G的一组匹配
在无权二分图中包含边数最多的一组匹配称为二分图的最大匹配

##### 交替路

从一个未匹配节点出发，依次经过非匹配边，匹配边，非匹配边....
这样交替的路径称为交替路

##### 增广路

从一个未匹配点出发，走交替路，若能到达另一个未匹配点，
则称这条路为增广路

观察增广路可以发现，只要把增广路中的所有匹配边进行性质反转
也就是让原本的匹配边变为非匹配边，
原本的非匹配边变为匹配边，
此时可以使得增广路上两端的两个未匹配点变为匹配点，
并且匹配边的数量增加 1，
路径中原本的匹配点也依旧保持是匹配点

所以这里的增广路就是指能增加匹配边数量的一条路

##### 匈牙利算法

本质就是不停的搜索增广路来增加匹配边数量
找不到增广路时，二分图就达到了最大匹配。
具体实现时可以通过DFS或者BFS来实现



#### 二分图的最大权匹配

最大权匹配是指当二分图是有权图时，
存在一个匹配使得该匹配子图的边的权值和是最大的

##### 完全匹配

在二分图的两个节点集合节点个数相等时，如果有一组匹配使得
图中每一个顶点都和图中某条边联系，称此时的匹配为完全匹配。

##### 顶标

给图中每个节点引入一个顶标，
使得任意一条边的两个顶点的顶标和要大于等于边的权值

##### 相等边

当图里的某条边的两个节点的顶标和等于这条边的权值时
称为这条边为相等边

##### 相等子图

一个图中所有边都是相等子边时，
称为这个图是相等子图

##### KM算法

KM算法是匈牙利算法的推广
它的本质是使用里一个引理：

如果相等子图存在完美匹配，那么该匹配就是二分图的最大匹配

对于两个点集个数不相等的二分图，我们用虚拟节点将节点少的集合补全
并增添权值为0的虚拟边，此时二分图就可以找到完美匹配了

实现上通过DFS或者BFS找到一组完美匹配，
并且完美匹配的边都属于相等子图即可
在寻找过程中使用顶标数值调整法，
在满足顶标数值要求的情况下不断调整顶标大小，
找出相等边，并且使相等边可以构成完美匹配
之后再删除掉虚拟节点和虚拟边就可得到最大权匹配。



#### 一般图匹配


可以参考一下博客：
https://blog.csdn.net/weixin_45735431/article/details/107392327

#### 一般图最大权匹配

省略可以参考一下博客：
https://blog.csdn.net/weixin_45735431/article/details/107392327



### 网络流问题

省略该问题，在下学期学校的图论书籍中会有详细的讲解。



### 图的其他问题

#### 差分约束

一根差分约束系统就是一个n元一次不等式组，
并且每个不等式的形式都是
     $x_{i}<=x_{j}+w_{ij}$
观察这个式子，不难发现这个式子和求最短路问题中松弛操作时的不等式：
     $dist[i]<=dist[j]+c_{ij}$
二者之间形式是相同的。
所以我们可以将求解一个差分约束不等式的问题转化为一个图论中的问题。
利用图论中的一些算法比如最短路算法来求解这些不等式问题。



#### 连通性

##### 有向图的强连通分量

强连通图指的是某个有向图所有节点之间都可互相到达。
强连通分量(SCC)就是极大的强连通子图。
很多时候我们都会研究图的强连通分量，
并将图中的一个强连通分量虚拟化为一个节点，
这样原本不规整的图就变为了一个有向无环图。
并且可以求该图的拓扑排序了，
这样可以简化对图的其他问题的求解。
同时求图的强连通分量还是很多经典算法的必要步骤之一。

##### tarjan算法

首先对图进行DFS搜索，每个节点只搜索一次。
被搜索过的节点与边构成了一个搜索树。

将图中所有的边可以分为四类：

1. 树边：DFS算法经过的边。
2. 返祖边：指向祖先节点的边。
3. 横叉边：搜索树中右子树指向左子树的边。
4. 前向边：指向子树中节点的边。

返祖边与树边一定构成环，与横叉边可能构成环，前向边无用。

tajan算法在具体实现时就是通过维护 dfn[ ] 数组与 low[ ] 数组，
维护者图中每个节点的信息，
dfn保存的是每个节点第一次被DFS搜索到的时间戳，
一般就是按照DFS搜索到的顺序从1开始排序，
low保存的是每个节点的所有连通节点中时间戳最小的节点的时间戳。

{具体实现有待补充}



##### 无向图的双连通分量

1. 边的双连通分量(e-dcc)：如果对于一条边，去掉这条边后图可以分成两个互不连通的块，那么称为这条边为桥，
     那么极大的，不包含桥的连通块就是边双连通分量

2. 点的双连通分量(v-dcc)：如果对于一个点，去掉这个点后图可以分为两个互不连通的块，那么这样的点被称为割点。

     极大的，不包含割点的连通块就是点双连通分量。





#### 欧拉回路

省略该问题，在下学期学校的图论课程中会有详细的讲解。
