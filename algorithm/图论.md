## 图论

### 基础概念

 #### 存储

1. 邻接矩阵法：用n*n的二维矩阵，将每行与每列都看作每个节点，
     矩阵里面某个行列对应数值表示这两个节点之间是否连接或者也可以定义为它们的权值。
     对于无向图而言，邻接矩阵还是对阵矩阵，在存储时可以压缩存储。 
     但存储稀疏矩阵时空间会有大量浪费。适合存储稠密图。
     ![](https://img-blog.csdnimg.cn/2a7d83f0822e4671936447372fe89487.png)
     
2. 邻接表法：
   
     通过链表来将连接某个节点的节点给串联起来。
     适合于存储稀疏图。
     
     二者对比：
     ![图论-20230925204242-2023-09-25-20-42-43](https://raw.githubusercontent.com/qingpingwan/note_picture/main/image_share_aux/图论-20230925204242-2023-09-25-20-42-43)
     
     
     
3. 十字链表：

     适合存储有向图，也没有邻接表找有向图入边不方便的问题。
     ![](https://img-blog.csdnimg.cn/20190219144848368.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3kxMDl5,size_16,color_FFFFFF,t_70)


​     

4. 邻接多重表：
     只能用于存储无向图。
     删除边，删除节点的操作都很方便。
     ![图论-20230925204332-2023-09-25-20-43-33](https://raw.githubusercontent.com/qingpingwan/note_picture/main/image_share_aux/图论-20230925204332-2023-09-25-20-43-33)

     

总的来说，**邻接矩阵** 与 **邻接表** 实际手写算法中使用较多。

十字链表与邻接多重表较复杂，仅需掌握其原理与实现方法即可。



### 图的遍历

同一个图的 **邻接矩阵** 表示法唯一，因此遍历结果的顺序唯一。

同一个图的 **邻接表** 表示方法不唯一，因此遍历结果可能不唯一。

#### BFS

（详见搜索章节）

#### DFS

（详见搜索章节）

#### 搜索与图的遍历

BFS与DFS绝不是只能使用在图的遍历搜索的过程中，
它们可以对遇到的大部分问题进行搜索。

在对于一个一般的算法问题，
我们把一个问题的求解看作是对问题状态空间的对应，
也就是将问题空间类比为一张图，
那么求解这个算法问题就相当于在在图上进行深度优先遍历。



### 最小生成树

n个节点的无向连通图的生成树有 n -1 个节点
生成树是不会有环的
注意只有无向图才有生成树

对于一个 **带权连通无向图** G = ( V , E ) ，找出该图的一个生成树 T，
使得该生成树的边权值和是最小的，称树T是G的最小生成树(MST)。

注意最小生成树可能有多个

#### Prim算法

运用贪心思维找局部最优解
可以从任意一个顶点开始构建最小生成树，连接这个顶点权值最小的边所对应的顶点
每次都以最小代价纳入一个新顶点到生成树中来，直到所有顶点都被纳入。

Prim适合于边比较稠密的图，这类图在存储时主要使用邻接矩阵进行存储。
因为一般Prim算法在存储图时就是以邻接矩阵的方式来存储图。

这个算法还可以类比Dijkstra算法来通过堆进行优化
也就是寻找目前距离生成树集合最近的点时可以使用堆进行优化。
```C++
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=510,INF=0x3f3f3f3f;
int n,m;
int Graph[N][N];  //使用邻接矩阵来存储图
bool st[N];       //标识一个节点是否在生成树的集合中
int Distance[N];
//用来标识目前没有在生成树集合中的节点距离该集合的最短路径

int Prim(){
	memset(Distance,0x3f,sizeof Distance);
	int res=0;
	for(int i=1;i<n;i++){
		int t=-1;
		for(int j=1;j<=n;j++){
			if(!st[j]&&(t==-1||Distance[t]>Distance[j]))
				t=j;
		//通过遍历Distance数组来找出目前距离生成树集合最近的点
		}
		if(i&&Distance[t]==INF) return INF;
		//如果现在最近的节点都是无穷远，那么说明不连通
		
		if(i) res+=Distance[t];
		//将新加入节点的距离算入生成树的总权值和中
		for(int j=1;j<=n;j++) Distance[j]=min(Distance[j],Graph[t][j]);
		//遍历所有节点，更新它们距离生成树集合的距离
		//注意这一步不能和上一步调换位置，一定先更新res值再更新Distance值
		//否则更新res值时可能用的新Distance值来加的，造成错误
		
		st[t]=true;
	}
	return res;
}

int main(){
	scanf("%d %d",&n,&m);
	memset(Graph,0x3f,sizeof Graph);
	while(m--){
		int a,b,c;
		scanf("%d %d %d",&a,&b,&c);
		Graph[a][b]=Graph[b][a]=min(Graph[a][b],c);
		//存储边时注意重边的影响，只存最小边
	}
	int t = Prim();
	if(t==INF) puts("impossible");
	else printf("%d\n",t);
	return 0;
}
```

#### Kruskal算法

也是采用贪心策略，不过是从边的角度来考虑问题
将所有边按照权值进行排序后，依次按权值从小到大考察这些边
如果一条边的两个端节点是不连通的，
那么就将这条边加入到最小生成树的集合之中。
如果边的两个端节点连通，那么就跳过这个边。

重复以上操作直到连接了n-1条边，此时就是最小生成树

在实现上我们可以借用并查集来判断两个节点是否是连通的。

#### Boruvka算法

Boruvka算法是一种用于求解最小生成树的贪心算法。
他也是最古老的最小生成树算法之一
它的基本思想是:

1. 初始时,将每个顶点看成是一个独立的树。
2. 找出每个树连接其他不同树的最小权值边, 连接这条边。
     这会使一些独立的树连接成更大的树。
3. 对现有的每棵树重复步骤2,直到所有顶点都在同一棵树内,
     这棵树就是最小生成树。

Boruvka算法像是Kruskal算法的多路增广版
它一次遍历就将每个独立的树连接其他树的最小权值边都加入到生成树中
在寻找最小权值边的过程中又考虑了树的生长

一般该算法并不一定优于Kruskal算法，仅作为参考算法来了解。





