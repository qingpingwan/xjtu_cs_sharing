
## 堆(优先队列)
### 基础

基本性质： 

优先队列可以理解为一个使用优先级来排序的队列，
每当入队一个元素后，就会按照优先级进行调整，
使得队头元素优先级最大或者优先级最小
同时还支持查询或者删除队头元素的操作

可并堆：

对于可并堆，除了支持优先队列的基本操作外，
还可以进行堆的合并操作，
也就是可以较高效的将两个堆合并为一个堆。
除了二叉堆与d堆外其他堆都是可并堆。



#### 二叉堆
![堆-20231102102017-2023-11-02-10-20-18](https://raw.githubusercontent.com/qingpingwan/note_picture/main/image_share_aux/堆-20231102102017-2023-11-02-10-20-18)

堆的目的是借用完全二叉树结构来快速实现不断找出集合中最大/最小值的能力。


**需要的操作：**

上滤( up )：考虑一个节点和其父节点的大小关系是否符合堆序性，如果不符合，那么将该节点值与父节点进行交换，使其符合堆序性。如果发生了交换，此时继续考虑父节点值与祖父节点值是否满足堆序性，
如果仍不满足，则继续迭代交换，直到满足为止。
宏观上看，这样的操作是从底向顶的上滤。

下滤(下浮)( down )：考虑一个节点和其子节点的大小关系是否符合堆序性，如果不符合，那么将该节点值与子节点进行交换，使其符合堆序性。如果发生了交换，则比较子节点与孙子节点的大小。
一直迭代进行比较与交换直到满足堆序性为止。
宏观上看，这样的操作是从顶向底的下滤。

 **实现原理：**


通过将二叉堆存储在数组中，通过下标的索引从而规避了指针的使用。

**实现方式:**

1. 初始化堆：将一个无序数组初始化为二叉堆，只需要从arr[ i/2] 开始一直遍历到arr[1]，

2. 删除任意一个节点：删除该节点后将最后一个节点放到此处，然后再实施 up 或 down 操作即可。

``` c++
void down(int u){
    int t=u;
    if(u*2<size && arr[u*2]<h[t]) t=u*2;
    if(u*2+1<size && arr[u*2+1]<arr[t]) t=u*2+1;
    if(u!=t){
        swap(arr[u],arr[t]);
        down[t];   //迭代的一直在下滤
    }
}

void up(int u){
    while( u/2 && arr[u/2]>arr[u]){
        swap(arr[u/2],a[u]);
        u/=2;
    }
}
```

### 补充

#### d堆

d堆是一种基于d叉堆的优先队列数据结构。
它类似于二叉堆,但每个节点可以有d个子节点,其中d>=2。

d堆通常用数组来存储。
并且可以类比二叉堆，d堆就是一个完全d叉树。
所以对于索引从0开始的数组,父节点和子节点的索引之间有以下关系:

- 父节点索引: (i-1)/d
- 子节点索引: i\*d + 1, i\*d + 2, ..., i\*d + d

数组的第一个元素作为根节点。

插入新元素时将新元素插入数组末尾，
再将新元素上浮到正确位置。
上浮过程采用与二叉堆类似的方式,不断比较父节点和子节点的值,
如果子节点更小,则交换两个节点。

删除最小元素操作
(1) 根节点就是最小元素,将根节点存储下来
(2) 将数组末尾元素移到根节点
(3) 将新的根节点下滤到正确位置

下滤过程也是不断比较父子节点的值,
如果父节点更大,则交换两个节点。

新建d堆并开始初始化时的原理与二叉堆的原理相同，
从无序数组建堆，并下滤(sift-down)操作,从左到右遍历数组进行下滤。

所以,通过数组表示、上浮下滤来维护d叉堆性质,就可以实现d堆这种优先队列结构。
相较于二叉堆,d堆可以减少树的高度,降低插入和删除的时间复杂度。
本质上说，d堆就是对二叉堆的一个推广，二叉堆就是 2-堆。



#### 左式堆

首先定于零路径长(npl)的概念：
将一个节点到其子节点中的叶子结点的最短路径长记作该节点的零路径长
叶子节点的零路径长记为0

左式堆，又称左偏树，它不满足二叉堆的结构性，但满足堆序性。
且对于任意一个节点，其左子树的路径长都大于右子树的路径长。
很显然，左式堆趋向于加深左路径。
注意左式堆也分为小根堆与大根堆。

合并操作是左式堆的基本操作，更是最重要的操作。
插入与删除节点的操作也是基于合并来实现的。

将（小根堆）左式堆H1与H2合并的实现如下：

比较H1与H2的根节点，
将根节点较大的左式堆与根节点较小左式堆的右子树进行合并。
**合并之后再比较新的左式堆的左右子树是否符合左偏的性质，
如果不满足左偏的性质，那么就将其左右子树进行交换。**

那么如何将根节点较大的左式堆与根节点较小左式堆的右子树进行合并呢？
只需要同样按照这个方法进行合并即可，
也就是说合并操作是递归进行的。

删除操作只会删除左式堆的最小值，也就是根节点，
那么此时只需要将左右子树进行一个合并操作即可。

对于插入操作，只需要将插入的节点看作只有一个节点的子树，
之后再进行合并操作即可。

需要清楚的是左式堆合并时不能直接将根节点值小的树的左子树与另一个左式堆递归合并，
因为如果采用这个策略合并那么最后会使得堆的右子树深度不改变，
而左子树的深度一直增加，很块就会退化成类似链表的结构了。

所以才要将根值小的堆的右子树与另一个左式堆进行递归合并，
这样做的目的就是让右子树的深度可以增加，提高了树的平衡性。
这样每次递归合并后返回时都要检查新生成左式堆的左右子树，
通过交换左右子树使其符合左偏性。
在不断检查与交换左右子树的过程中，使得左右子树的深度都在增加，
从而使树相对变的平衡一些。

#### 斜堆

斜堆是左偏树的一种变种，它是一棵有序二叉树，但是它不满足左偏的性质。
也就是说斜堆并不保留节点的零路径长(npl)值。
所以从结构上看，所有左偏树都是斜堆。

类似与左偏树，斜堆所有的操作都是在合并的基础上完成的。

斜堆的合并操作的递归过程和左偏树基本相同。
假设要合并两个斜堆A和B，且A的根节点比B的根节点小。
只需将A的根节点作为合并后新堆的根节点，
并将A的右子树与B再进行递归的合并操作即可。

但是经过合并之后新堆的最右零路径长度就会增加，累积之下就会影响效率，
为了解决这一问题，左偏树在进行合并的同时，每次递归合并返回后，
都会检查新生成子堆的npl值，如果大于大于它的兄弟子堆，
那么就会将左右子堆进行交换，使得最右零路径长度维持的比较小，
提高了合并操作的效率。

那么对于斜堆，由于并未计算与存储节点的npl值，
所以斜堆的策略是沿着合并的道路，
每次递归调用返回时都会直接交换左右子树。

这种直接交换子树的方法使得斜堆在一定程度上也可以趋于平衡，
防止退化成了链表，提高了摊还分析的复杂度。



#### 二项堆

首先定义k阶二项树：

1. 度数为0的二项树只包含一个结点
2. 度数为k的二项树有一个根结点，根结点下有k个子女，
     每个子女分别是度数为k-1,k-2,…,0的二项树的根

从二项树的性质不难推断出一个k阶二项树有$2^{k}$个节点，
并且两个k阶二项树就可以合并为一个k-1阶二项树。

二项堆是二项树的集合，并且满足：

1. 每棵二项树都有堆序性，即父节点小于儿子节点值（最小堆）
2. 不能有两棵及两棵以上的二项树度数相同。

对于二项堆的合并其实本质可以看作是二进制加法，
将两个二项堆直接合并后开始考察新的二项堆是否满足第二条性质，
如果不满足，也就是有两个二项树的度数都是k，
那么就开始进行二叉树的合并操作，将它们合并为度数k+1的二项树，
之后再检查是否满足二项堆的性质，如果仍不满足就继续合并二项树，
一直进行合并操作直到满足二叉堆的性质为止。

与二叉堆相比,二项堆牺牲了删除最小元素的性能来加速合并操作,
适合需要频繁合并的应用场景。



#### 配对堆
可以参考以下博客：
https://blog.csdn.net/m0_72987309/article/details/129539485



#### 斐波那契堆

斐波那契堆是一种理论效果非常好的数据结构，但实际上用到生产中的并不多，
主要是实现起来比较复杂，而且只是理论的复杂度比较低，常数有时会比较大。

